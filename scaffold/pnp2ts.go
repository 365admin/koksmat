package scaffold

import (
	"encoding/xml"
	"fmt"
	"io/ioutil"
	"os"
	"path"
	"strings"
)

func createProject(dir string) string {

	os.MkdirAll(dir, os.ModePerm)

	return dir
}
func createSubdir(projDir string, subDir string) string {

	dir := path.Join(projDir, subDir)
	os.MkdirAll(dir, os.ModePerm)

	return dir
}
func writeFile(fileDir string, filename string, content string) {

	file, err := os.Create(path.Join(fileDir, filename))
	if err != nil {
		fmt.Println(err)
		return
	}
	defer file.Close()

	file.WriteString(content)
}

func OutTS(projDir string, list ListInstance, moduleName string) string {

	itemsMap := fmt.Sprintf(`

	export function mapLookup(listName:string,item:any) {
		return item ? {LookupId:parseInt(item),LookupValue:"id " + item + " in " + listName  }: null
	}
	export function mapLookupMulti(listName:string,item:any) {

		return null
	}
// %s
	export function map(item:any) {
	
	
	return {
		Id : item.id,
	Title : item.fields.Title,
	eTag : JSON.parse(item.eTag),
	CreatedBy : item.createdBy.user.email ?? item.createdBy.user.displayName,
	Created :new Date(item.createdDateTime),
	ModifiedBy : item.lastModifiedBy.user.email ?? item.lastModifiedBy.user.displayName,
	Modified : new Date(item.lastModifiedDateTime),	
		`, list.Title)

	zodMaps := `
	export const schema = z.object({
		CreatedBy : z.string(),
		Created: z.date(),
		ModifiedBy : z.string(),
		Modified: z.date(),
		Id: z.string(),
		eTag : z.string(),
		Title: z.string(),
		
		`

	formFields := ``
	tableFields := ``

	var standardFields []string = []string{"Id", "Title", "CreatedBy", "Created", "ModifiedBy", "Modified"}

	formFields += FormTextfield("Title", "Title", "")
	tableFields += TableTextColumn("Title", "Title")
	tableFields += TableTextColumn("CreatedBy", "Created By")
	tableFields += TableDateColumn("Created", "Created")
	tableFields += TableTextColumn("ModifiedBy", "Modified By")
	tableFields += TableDateColumn("Modified", "Modified")

	var fieldNames []string = []string{}
	var dependencies []string = []string{}
	for _, field := range standardFields {
		fieldNames = append(fieldNames, fmt.Sprintf("\"%s\"", field))
	}
	for _, field := range list.Fields.Field {
		if field.Name == "_ColorTag" {
			break
		}
		fieldMap, zodMap, formField, tableField := GetTsField(field)
		tableFields += tableField
		if field.Type == "Lookup" || field.Type == "LookupMulti" {
			dependencies = append(dependencies, fmt.Sprintf(`"%s"`, strings.ReplaceAll(strings.ReplaceAll(field.List, "{listid:", ""), "}", "")))
		}
		fieldNames = append(fieldNames, fmt.Sprintf("\"%s\"", field.Name))
		if fieldMap != "" {
			itemsMap += fmt.Sprintf(`%s: %s,
			`, field.Name, fieldMap)

		}
		if zodMap != "" {
			zodMaps += fmt.Sprintf(`%s,
			`, zodMap)

		}

		formFields += formField

	}
	itemsMap += "}}"
	zodMaps += `})
	
	export type ItemType = z.infer<typeof schema>
	`
	sharepointMap := ""

	sharepointMap += fmt.Sprintf(`
	import z from "zod"

		export const listName = "%s"
		export const listURL = "%s"
		`, list.Title, list.URL)

	sharepointMap += fmt.Sprintf(`export type FieldNames = %s
	`, strings.Join(fieldNames, "|"))
	sharepointMap += fmt.Sprintf(`export const dependencies =[%s]
	`, strings.Join(dependencies, ","))
	sharepointMap += itemsMap

	sharepointMap += zodMaps
	//sharepointMap += "}"
	listName := strings.ReplaceAll(list.Title, " ", "")
	listDir := createSubdir(projDir, listName)
	itemDir := createSubdir(listDir, "[itemid]")

	writeFile(listDir, fmt.Sprintf("index.ts"), sharepointMap)
	writeFile(listDir, fmt.Sprintf("form.tsx"), formCode(listName, formFields))
	writeFile(listDir, fmt.Sprintf("table.tsx"), tableCode(listName, tableFields, moduleName))
	writeFile(listDir, fmt.Sprintf("page.tsx"), listPageCode(listName, ""))
	writeFile(itemDir, fmt.Sprintf("page.tsx"), itemPageCode(listName, ""))
	return sharepointMap

}

func Pnp2Ts(sitename string, filename string, moduleName string) string {

	projDir := createProject(sitename) //time.Now().Format("2006-01-02T15:04:05"))
	dollarDir := createSubdir(projDir, "$")
	// Open our xmlFile
	xmlFile, err := os.Open(filename)
	// if we os.Open returns an error then handle it
	if err != nil {
		fmt.Println(err)
	}

	//fmt.Println("Successfully Opened template.xml")
	// defer the closing of our xmlFile so that we can parse it later on
	defer xmlFile.Close()

	// read our opened xmlFile as a byte array.
	byteValue, _ := ioutil.ReadAll(xmlFile)

	// we initialize our Users array
	var template Provisioning
	// we unmarshal our byteArray which contains our
	// xmlFiles content into 'users' which we defined above
	xml.Unmarshal(byteValue, &template)

	// we iterate through every list within our template
	sharepointMap := `
	// ************************************************************
	// Generated by pnp2ts - do not edit
	// www.koksmat.com
	// ************************************************************

	import { https, httpsGetAll } from "@/lib/httphelper"
	import z from "zod"

	function mapLookup(item:any) {
		if (!item) return null
		return {
			LookupId: item.LookupId,
			LookupValue: item.LookupValue
		}
	}

	function mapLookupMulti(items:any[]) {
		if (!items) return []
		return items.map(item =>
		{
			return {LookupId: item.LookupId,
				LookupValue: item.LookupValue}
		})
	}

	`
	fields := []Field{}
	fields = append(fields, Field{
		Name:        "Name",
		DisplayName: "Name",
		Type:        "Text",
	})
	fields = append(fields, Field{
		Name:        "IsSiteAdmin",
		DisplayName: "IsSiteAdmin",
		Type:        "Boolean",
	})
	fields = append(fields, Field{
		Name:        "EMail",
		DisplayName: "EMail",
		Type:        "Text",
	})
	fields = append(fields, Field{
		Name:        "Notes",
		DisplayName: "Notes",
		Type:        "Text",
	})
	fields = append(fields, Field{
		Name:        "ContentType",
		DisplayName: "ContentType",
		Type:        "Text",
	})

	userInformationList := ListInstance{
		Title: "User Information List",
		URL:   "User Information List",
		Fields: Fields{
			Field: fields,
		},
	}
	listInstances := append(template.Templates.ProvisioningTemplate.Lists.ListInstance, userInformationList)
	for _, list := range listInstances {
		sharepointMap += OutTS(projDir, list, moduleName)
	}
	mapSrc := `
	// ************************************************************
	// Generated by pnp2ts - do not edit
	// www.koksmat.com
	// v0.1.0
	// ************************************************************
	

	
	
	
	`
	linkSrc := `
	"use client"
	// ************************************************************
	// Generated by pnp2ts - do not edit .
	// www.koksmat.com
	// v0.1.0
	// ************************************************************

	import Link from "next/link";
	import { Button } from "@/registry/new-york/ui/button";
	import { ShowDefinitions } from "@/app/sharepoint/components/showlistsDefinitions";
import { useContext } from "react";
import { MagicboxContext } from "@/app/magicbox-context";
import { map } from "..";
	


	export default function Page({params}:{params:{site:string}}) {
		const magicbox = useContext(MagicboxContext);
		return (<div>
	`

	for _, list := range listInstances {
		listName := strings.ReplaceAll(list.Title, " ", "")

		linkSrc += fmt.Sprintf(`
<div>
		<Button variant={"link"}><Link href="./%s">%s</Link></Button>		
</div>
`, listName, list.Title)

		mapSrc += fmt.Sprintf(`
import { listName as %sList,dependencies as %sDependencies } from "./%s";`, listName, listName, listName)
	}

	mapSrc += `
export function map(){

	const dependencies = []
`

	for _, list := range listInstances {
		listName := strings.ReplaceAll(list.Title, " ", "")
		mapSrc += fmt.Sprintf(`
dependencies.push({listName : %sList,
dependencies:  %sDependencies }) `, listName, listName)
	}
	mapSrc += `


	return dependencies
}

`
	linkSrc += `
	<ShowDefinitions tenant={magicbox.tenant} site={params.site} map={map()} />
	</div>)
}

`
	writeFile(projDir, "index.ts", mapSrc)
	writeFile(dollarDir, "page.tsx", linkSrc)
	return sharepointMap

}
